// src/ThreeScene.jsx

import { Suspense } from "react";
import * as THREE from "three";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import {
  Environment,
  useGLTF,
  Center,
  ScrollControls,
  useScroll,
} from "@react-three/drei";

// ====== 타임라인(키프레임) 공통 정의 ======
const KEYS = [
  { pos: new THREE.Vector3(180, 180, 180), look: new THREE.Vector3(0, 0, 0), fov: 50 }, // front
  { pos: new THREE.Vector3(140, 50, 250), look: new THREE.Vector3(0, 20, 0), fov: 60 }, // right
  { pos: new THREE.Vector3(-220, 70, 160), look: new THREE.Vector3(0, 25, 0), fov: 40 }, // left
  { pos: new THREE.Vector3(0, 360, 90), look: new THREE.Vector3(0, 0, 0), fov: 55 }, // top
];

// ★ 이동은 길게, 홀드는 짧게 (전환이 길게 보이도록)
const MOVE_DUR = [1.8, 1.8, 1.8];
const HOLD_DUR = [0.25, 0.25, 0.25, 0.25];

const TIMELINE = (() => {
  const segs = [];
  let t = 0;
  segs.push({ type: "hold", key: 0, s: t, e: (t += HOLD_DUR[0]) });
  for (let i = 0; i < KEYS.length - 1; i++) {
    segs.push({ type: "move", a: i, b: i + 1, s: t, e: (t += MOVE_DUR[i]) });
    segs.push({ type: "hold", key: i + 1, s: t, e: (t += HOLD_DUR[i + 1]) });
  }
  return { segments: segs, total: t };
})();

const ease = (x) => 0.5 * (1 - Math.cos(Math.PI * x));

// ====== 모델 경로 ======
const MODEL_URL = `${import.meta.env.BASE_URL}models/scene.gltf`;

/* 3D 모델 */
function Model() {
  const { scene } = useGLTF(MODEL_URL);
  return (
    <Center>
      <primitive object={scene} dispose={null} />
    </Center>
  );
}
useGLTF.preload(MODEL_URL);

/* 스크롤 기반 카메라 이동 + 홀드 */
function CameraRig() {
  const { camera } = useThree();
  const scroll = useScroll();
  const { segments, total } = TIMELINE;

  useFrame(() => {
    const time = THREE.MathUtils.clamp(scroll.offset, 0, 1) * total;
    const seg = segments.find((s) => time >= s.s && time <= s.e) ?? segments.at(-1);

    if (seg.type === "hold") {
      const k = KEYS[seg.key];
      camera.position.lerp(k.pos, 0.2);               // ★ 살짝 더 느리게
      camera.lookAt(k.look);
      camera.fov = THREE.MathUtils.lerp(camera.fov, k.fov, 0.2);
      camera.updateProjectionMatrix();
      return;
    }

    const a = KEYS[seg.a], b = KEYS[seg.b];
    const f = ease((time - seg.s) / (seg.e - seg.s));
    const pos = a.pos.clone().lerp(b.pos, f);
    const look = a.look.clone().lerp(b.look, f);
    const fov = THREE.MathUtils.lerp(a.fov, b.fov, f);

    camera.position.lerp(pos, 0.12);                 // ★ 이동 추종 더 느리게
    camera.lookAt(look);
    camera.fov = THREE.MathUtils.lerp(camera.fov, fov, 0.12);
    camera.updateProjectionMatrix();
  });

  return null;
}

export default function ThreeScene() {
  return (
    <Canvas camera={{ position: [140, 50, 250], fov: 50, near: 0.1, far: 2000 }}>
      <color attach="background" args={["#0b0f14"]} />
      <ambientLight intensity={0.5} />
      <directionalLight position={[3, 5, 2]} intensity={1.2} />

      <Suspense fallback={null}>
        <ScrollControls pages={6} damping={0.12}>
          <Model />
          <CameraRig />
        </ScrollControls>
        <Environment preset="city" />
      </Suspense>
    </Canvas>
  );
}